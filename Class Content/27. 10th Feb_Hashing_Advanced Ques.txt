Date : 10th February 2024
Mentor: DEVANG SHARMA
Batch: Oct Batch (DSA) - Tutort Academy

Agenda:

- Sorting - Theory + Questions: DONE
- Sorting LC Questions: DONE
https://leetcode.com/problems/kth-largest-element-in-an-array/: DONE
https://leetcode.com/problems/sort-colors/: DONE
https://leetcode.com/problems/largest-number/: DONE
https://leetcode.com/problems/sort-list/: DONE
https://leetcode.com/problems/contains-duplicate/: DONE
https://leetcode.com/problems/contains-duplicate-ii/: DONE
https://leetcode.com/problems/contains-duplicate-iii/: DONE

- Hashing- Sets and Maps: Questions
https://leetcode.com/problems/isomorphic-strings/ - IMP - 
https://leetcode.com/problems/longest-consecutive-sequence/ - IMP - 

TODO:
https://leetcode.com/problems/find-the-difference/ - 
https://leetcode.com/problems/most-common-word/ - IMP - 

https://leetcode.com/problems/ugly-number-ii/
https://leetcode.com/problems/majority-element-ii/

- Recursion - Questions
- Queue: LC Questions
- Dynamic Programming 


"Please Type 'Hi' in the Chat Box if you have joined and Can See this Screen".






Q-9: [LC-389] Find the Difference
https://leetcode.com/problems/find-the-difference/description/


You are given two strings s and t.

String t is generated by random shuffling string s and then add one more letter at a random position.

Return the letter that was added to t.

 

Example 1:

Input: s = "abcd", t = "abcde"
Output: "e"
Explanation: 'e' is the letter that was added.


Example 2:

Input: s = "", t = "y"
Output: "y"
 

Constraints:

0 <= s.length <= 1000
t.length == s.length + 1
s and t consist of lowercase English letters.



    public char findTheDifference(String s, String t) 
    {
        
    }



Solution:


Input: s = "abcd", t = "abcda"
Output: "a"

Set: Not Correct DS - Duplicates Can Exist



(1) Brute Force: Two Nested Loops

s[i]!=t[j]

TC: O(N^2), SC: O(1)


(2) Sorting and Two Pointers

s.sort(), t.sort()

"abcd"       "abcde"
 ^            ^
p1            p2

TC: O(MlogM) + O(NlogN) + O(M) + O(N), SC: O(1)


(3) Map - Count for Each Character and compare Maps
- 2 Different Maps, Cmapre the Non Common Key or Non Common Values


Input: s = "abcd", t = "abcde"

mp1 = {a-1, b-1, c-1, d-1}
mp2 = {a-1, b-1, c-1, d-1, e-1}

TC: O(N) + O(N)
SC: O(26) + O(26)



(4) Map- Count for Each Character and chek if freq!=0

1 Map:

Traverse s, Increment
Traverse t, Decrement

Input: s = "abcd", t = "abcde"

mp = {a-1, b-1, c-1, d-1} (++)
mp = {a-0, b-0, c-0, d-0, e-(-1)} (--)

OP: e


If freq!=0 -> If value!=0, return key


TC: O(N)
SC: O(26)


(5) Array - Count for Each Character and compare Arrays
- 2 Different Arrays, Cmapre the Non Common Key or Non Common Values

TC: O(N) + O(N)
SC: O(26) + O(26)

(6) Array - Count for Each Character and chek if freq!=0

1 Array:

TC: O(N)
SC: O(26)



(7) XOR -> Two Pass

(8) XOR -> 1 Pass


A^A = 0
Only pending OP = Extra Character

Concatenate 2 Strings, Apply XOR on values, Result would be XOR of All Values

(9) Sum of ASCII Characters

0 <= s.length <= 1000
s and t consist of lowercase English letters.


a-z: 97 to 122
A-Z: 65 to 90


Sum = Max: "zzzzzzz.....1000 Characters" = 122,000 : Within int Range




(10) Sum of ASCII Characters Using Modulo

0 <= s.length <= 10^9
s and t consist of lowercase English letters.

a-z: 97 to 122
A-Z: 65 to 90

Sum = Max: "zzzzzzz.....10^9 Characters" = 1.22 * 10^11 : Not within int Range

Modulo Trick: sum %= 256; (Sum Always from 0 to 255)




Task: Given Two Numbers, Find the uncommon digit

p = 123
q = 1234

Sum of digits and subtract -> Ans

sum(p) = 6
sum(q) = 10

diff = uncommon digit = 10-6 = 4 : ANS


Extend to String:

p = "abc"
q = "abcd"

Every Character is Mapped to its ASCII Value


(1) sum += t[i]
sum = a + b + c + d (97 + 98 + 99 + 100)

(2) sum -= s[i]
sum = d (100)

return (char) sum;





CODE:


// TC: O(S) + O(T)
// SC: O(1)

class Solution {
public:
    char findTheDifference(string s, string t) 
    {
        int sum = 0;

        for (auto &c: t)
            (sum += c) %= 256;

        for (auto &c: s)
            (sum -= c) %= 256;

        return (char)sum;
    }
};




















Q-10: [LC-819] Most Common Word
https://leetcode.com/problems/most-common-word/description/

Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.

The words in paragraph are case-insensitive and the answer should be returned in lowercase.

 

Example 1:

Input: paragraph = "Bob hit a ball, the hit BALL flew far after it was hit.", banned = ["hit"]

Output: "ball"

Explanation: 

"hit" occurs 3 times, but it is a banned word.
"ball" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. 
Note that words in the paragraph are not case sensitive,
that punctuation is ignored (even if adjacent to words, such as "ball,"), 
and that "hit" isn't the answer even though it occurs more because it is banned.


Example 2:

Input: paragraph = "a.", banned = []

Output: "a"
 

Constraints:

1 <= paragraph.length <= 1000
paragraph consists of English letters, space ' ', or one of the symbols: "!?',;.".
0 <= banned.length <= 100
1 <= banned[i].length <= 10
banned[i] consists of only lowercase English letters.




------> Understanding:

(1) Ignore Punctuations
"balls." ------> "balls"

(2) Ignore Extra Chacaters and Spaces
 "!?',;." or ' '

(3) Ignore Upper and Lower Case

(4) Check Word is NOT Banned

(5) Find Most frequent Word: Count


It is guaranteed there is at least one word that is not banned, and that the answer is unique.



    public String mostCommonWord(String paragraph, String[] banned) 
    {

    }


Solution:

(1) Convert paragraph into Array of Strings

paragraph ------> String[] words

Remove Extra Characters ( "!?',;.") and Spaces (' ')

- Using Regex
- Using Split


(2) Convert All Strings in String[] words to Lowercase:

Constraints:
banned[i] consists of only lowercase English letters.

- I have to match the words present in words[] NOT present in banned[]


(3) String[] words and String[] banned


Ques: Find Most Common Word present in words, NOT Present in banned[]

Best: Set

Convert Banned Words into Set and then lookup over words in O(1) Time


(4) Highest Frequency Not in Banned -----> Map

Map:

Key: Word
Value: Frequency






CODE:



class Solution {
    public String mostCommonWord(String paragraph, String[] banned) 
    {
    // Create Set out of banned Array, lookup - O(1)
    Set<String> banSet = new HashSet<String>(Arrays.asList(banned));

    // hashmap for frequency of most common word
    Map<String, Integer> count = new HashMap<String, Integer>();

    // Create words array using regex and convert to lowercase
    // Constraints: banned[i] consists of only lowercase English letters.
    // "ball." -> "ball" -> [ball]

    String[] words = paragraph.replaceAll("\\W+", " ").toLowerCase().split("\\s+"); // O(N) 

    for (String word: words) // O(N)
    {
        // if word is not banned, put into map
        if(!banSet.contains(word)) // O(1)
            {
                count.put(word, count.getOrDefault(word, 0) + 1);
            }
    }

    // Return the key with Highest Frequency (Value)
    return Collections.max(count.entrySet(), Map.Entry.comparingByValue()).getKey();
    }
}


TC: O(N)
SC: O(words) + O(banned)


"Ball,. value" ----> 		"Ball value" 			-----> "ball value"  -----------> [ball, value]"
                     replaceAll("\\W+", " ")             toLowerCase()                  split("\\s+")


















-------> WHAT?

Hashing: Algorithm
Sets and Maps: DS built on concept of Hashing


Hashing:

Morphing a Data into another Form is calld Hashing
Large Value -----> Smaller Value





Arrays:
- Similar type of data types, Random Access
- Fixed Size

arr[idx]: O(1)


Linked Lists:
- Dynamic Allocation
- No Fixed Size


Stacks:
- Most Recently Used Element in O(1) Time
- LIFO


Queues:
- Least Recently Used Element in O(1) Time
- FIFO



"We DELIBERATELY Store Values in a PARTICULAR ORDER (Insertion/Deletion) to Solve SPECIFIC Use Case"


Eg:

Stack:

Insertion: Top
Deletion: Top

Use Case: Most Recently Used Element in O(1) Time




Eg:


Queue:

Insertion: Rear
Deletion: Front


Use Case: Least Recently Used Element in O(1) Time












Hashing:

Large Value -------> Hash Function -----> Smaller Value


Use Case:

(1) Insertion: O(1)
(2) Search/Retreival: O(1)



Class: 
500 Students
- Contact Numbers

Requirements:
(1) Insert a New Number: ASAP: O(1)
(2) Search for Any Given Number: ASAP: O(1)



Solution:


Array:
Insertion: O(1) - End

Search: O(N) - Unsorted , O(log N) - Sorted


Any Way I can do search in O(1) in Array? - No



Linked List:

Insertion: O(1)
Search: O(N)


Stacks:

Insertion: O(1)
Search: O(N)


Queues:

Insertion: O(1)
Search: O(N)



Trees:

BT: O(N)
BST: O(log N)







Requirements:
(1) Insert a New Number: ASAP: O(1)
(2) Search for Any Given Number: ASAP: O(1)


YES - O(1)
HASHING - O(1)



element ------> Hash Function() ------> Hash Value
Hash Value ------> Used as Index in HashTable




A = [11, 12, 13, 14, 15]

hash(element) = "val"
Use that "val" (Hash Value) as Index in Hash Table


h() = element % 10 - HASH FUNCTION - O(1)

Hash Values = ans = A[i] % 10 = [1, 2, 3, 4, 5] - Hash Values

HashTable:

0:
1: 11
2: 12
3: 13
4: 14
5: 15




Search: 


Find(11)

- Calculate Hash Value Using Hash Function
- Go to that Hash Value index in Hash Table


11 % 10 = 1        // O(1)
HT[1] ----> value  // O(1)


Total: O(1)





Insertion:

insertion(16)
- Calculate Hash Value Using Hash Function
- Go to that Hash Value index in Hash Table and insert element there


16 % 10 = 6      // O(1)
HT[6] = 16       // O(1)

Total: O(1)




--------> Good Hash Function:


(1) Efficiently Computable - Preferably in O(1) 

(2) Less Space

You have 100 Mn Values
It should not give Index for 100 Million Views


(3) Uniformly Distributed

100 Elements: Chances of getting into HashTable should be equal for all values



DB Company:

- Google Search
- Yandex
- CouchDB
- YugaByte




LIVE EXAMPLE:
Google Search: DONE


Better Hash Function ----> Less Latency (Look Up Time) and Larger Result Sets











--------> Dynamic Programming (DP)


1-10
Avg: 1-2


Recursion: (1-10)
Avg: 5-6


Target: DP: 8-9







------> DP vs Backtracking vs Greedy



DP:
- Optimisation Over Recursion
- Storing the results of previous states to avoid recalculating again and again

Eg: 0-1 Knapsack, LCS, LIS etc


Backtracking:
- Optimisation Over Recursion Without Storing the state Results
- Exhaust All Possible States

Eg: Rat in a Maze, N Queens


Greedy:
- Find me the BEST Solution NOW
- DONT THINK ABOUT FUTURE

(Local Maxima/Minima == Global Maxima/Minima)

Eg: Coin Change Problem





















-----> DP vs Greedy: Practical Example

Eg: GoldMine Question


Given a Matrix,
Each Cell Contains Gold Coins
Calculate Max Gold Coins in the Matrix

Constraints:
- Right or Down
- S and D Given



[
S: 1    10     20
   100  1000    25
   70    80     90: D
]

S-D Path?

Ans: 1 100 1000 80 90






-----> DP Way:


Find All S-D Valid Paths and then Check for Maximum

1 10 1000 25 90: VALID
1 10 1000 80 90: VALID
1 100 1000 25 90: VALID
1 100 1000 80 90: VALID - ANS
.....................



------> Greedy Way:

You are at 1: 10 or 100

According to Greedy,
"ALWAYS" Go to 100 because MAX(10,100) = 100

AT Every Step, Choose the BEST SOLUTION There,
DONT THINK ABOUT FUTURE


Note:
Greedy will NOT Always Give you correct Answers



Test case-1:

[
S: 1    10     20
   100  1000    25
   70    80     90: D
]


Expected OP: 1 100 1000 80 90

Greedy OP: 1 -> 100 (10/100) -> 1000 (70/1000) -> 80 (25/80) -> 90
		 : 1 100 1000 80 90 : CORRECT







Test case-2:

[
S: 1    10      2000
   100  1000    25
   70    80     90: D
]


Expected OP: 1 10 2000 25 90

Greedy OP: 1 -> 100 (10/100) -> 1000 (70/1000) -> 80 (25/80) -> 90
		 : 1 100 1000 80 90 : INCORRECT



















